#### 桶排序

##### 实现逻辑：

1.设置一个定量数组当作空桶子

2.寻访序列，并且把项目一个一个放到对应的桶子去

3.对每个不是空的桶子进行排序

4.从不是空的桶子里把项目再放回原来的序列中

##### 时间复杂度：O(N+M)

```c
#include<stdio.h>
int main()
{
int a[11];
int i;
int j;
int t;
for(i=0;i<=10;i++)
   a[i]=0;//初始化为0
for(i=1;i<=5;i++)//循环读入5个数
{
	scanf("%d",&t);//把每一个数读入变量t中
	a[t]++;//进行计数
}
for(i=0;i<=10;i++)//依次判断a[0]到a[10]
   for(j=1;j<=a[i];j++)//出现几次就打印几次
       printf("%d",i);
   getchar();getchar();//这里的getchar();用来暂停程序，以便查看程序输出的内容
   //也可以用system("pause");等来代替
   return 0;
}
```

<img src="C:\Users\任海霞\AppData\Roaming\Typora\typora-user-images\image-20210506164522977.png" alt="image-20210506164522977" style="zoom:50%;" />

```c
#include<stdio.h>
int main()
{
	int book[1001],i,j,t,n;
	for(i=0;i<=1000;i++)
		book[i]=0;
	scanf("%d",&n);//输入一个数n，表示接下来有n个数
	for(i=1;i<=n;i++)//循环读入n个数，并进行桶排序
	{
		scanf("%d",&t);//把每一个数读入变量t中
		book[t]++;//进行计数，对编号为t的桶放一个小旗子
	}
	for(i=1000;i>=0;i--)//依次判断编号1000到0的桶
		for(j=1;j<=book[i];j++)//出现了几次就将桶的编号打印几次
			printf("%d",i);
		getchar();getchar();
		return 0;
}
```

<img src="C:\Users\任海霞\AppData\Roaming\Typora\typora-user-images\image-20210506203007748.png" alt="image-20210506203007748" style="zoom: 50%;" />

#### 冒泡排序

##### 算法描述：

1.比较相邻的的元素，如果第一个比第二个大，就交换它们两个

2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数

3.针对所有的元素重复以上的步骤，除了最后一个

4.重复步骤1~3，直到排序完成

##### 时间复杂度：O(N^2)

```c
#include<stdio.h>
int main()
{
	int a[100],i,j,t,n;
	scanf("%d",&n);//输入一个数n，表示接下来有n个数
	for(i=1;i<=n;i++)//循环读入n个数到数组a中
		scanf("%d",&a[i]);//冒泡排序的核心部分
	

		for(j=1;j<=n-i;j++)//n个数排序，只用进行n-1趟
		{
			for(j=1;i<=n-i;i++)//从第1位开始比较直到最后一个尚未归位的数
			{
				if(a[j]<a[j+1])//比较大小并交换
				{
					t=a[j];
					a[j]=a[j+1];
					a[j+1]=t;
				}
			}
		}
		for(i=1;i<=n;i++)//输出结果
			printf("%d",a[i]\n);
		getchar();getchar();
		return 0;
}

```

<img src="C:\Users\任海霞\AppData\Roaming\Typora\typora-user-images\image-20210506205606938.png" alt="image-20210506205606938" style="zoom:50%;" />



#### 快速排序

##### 算法步骤：

1.从数列中挑出一个元素，称为“基准（pivot）”

2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆在基准的后面（相同的数可以到任一边）在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作

3.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序

##### 时间复杂度：O(NlogN)

```c
#include<stdio.h>
int a[101];
int n;

void quicksort(int left,int right)
{
	int i;
	int j;
	int t;
	int temp;
	if(left>right)
		return;
	temp=a[left];//temp中存的就是基准数
	i=left;
	j=right;
	while(i!=j)
	{
		//顺序，要先从右往左找
		while(a[j]>=temp && i<j)
			j--;
		//再从左往右找
		while(a[i]<=temp && i<j)
			i++;
		//交换两个数在数组中的位置
		if(i<j)   //哨兵i和j没有相遇时 
		{
			t=a[i];
			a[i]=a[j];
			a[j]=t;
		}
	}
	//最终将基准数归位

	a[left]=a[i];
	a[i]=temp;
	
	quicksort(left,i-1);//继续处理左边的，（这里是一个递归过程）
	quicksort(i+1,right);//继续处理右边的，（这里是一个递归过程）

}

int main()
{
	int i;
	int j;
	int t;
	//读入数据
	scanf("%d",&a[i]);

	quicksort(1,n);//快速排序调用
	
	//输出排序后的结果
	for(i=1;i<=n;i++)
		printf("%d",a[i]);
	getchar();getchar();
	return 0;

}


```

